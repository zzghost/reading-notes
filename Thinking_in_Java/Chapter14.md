## Chapter 14 RTTI（一大堆坑待填）
### 14.1 为什么要用RTTI
简单来说，“多态”是面向对象编程的基本目标，而这是基于RTTI来实现的，而RTTI又是通过Class对象来完成的
### 14.2 Class对象
每个类都会有一个Class对象。在编写后并且编译一个新类时，就会产生一个Class底箱。为了生成一个类的这个对象，JVM使用了*类加载器*子系统。这个子系统可以包含一系列类加载器链，但是只有一个*原生类加载器*，它加载可信类，比如Java API类。
Java的一个特性就是，所有类都是动态加载到JVM中的。所以Java程序在它刚开始运行时没有都加载，而是各个部分在需要时才会被加载进来。类加载器首先会检查Class对象是否已经加载。如果没有，就去查找.class文件。在加载入内存后，它就会被用来创建这个类的所有对象。
当程序创建第一个对类的静态成员的引用时，就会加载这个类，这个说明即使没有标明static, 类的构造器也是类的静态方法。在使用new操作符创建类的新对象时，这个过程也被当作是对类的静态成员的引用。
Java有以下两种方法来获取对Class对象的引用：
1） Class.forName("classname"):找加载类，如果找不到则抛出ClassNotFoundException的异常。和2）不同的是，这种方法调用后会立刻进行初始化。
2） ClassName.class.基本类型也包含.class方法，而他们的包装器类则有.TYPE字段，作者建议使用.class，为了保持一致。
.class的准备工作有三个：1） 加载，类加载器会去查找字节码，从字节码中创建Class对象。2） 链接，验证字节码，为静态域分配存储空间，并且若必需的话，将解析这个类创建的对其他类的所有引用。 3）初始化，如果该类具有超类，则对其初始化，执行静态初始化器和初始化块。。。。所以使用.class来创建Class对象的引用时，不会自动初始化该Class对象，而是延迟到了对静态方法或者非常数静态域进行首次引用时才执行。
关于此过程，书P319给出了一个详细的例子，对于理解初始化比较有用，可以再复习。这个例子说明，对于static final型的编译时常量，所以不需要初始化就可以直接读取，但是只加上static final却不能保证可以直接读取，因为它有可能跟超类有关，这就需要用到上边第3）条，强制初始化，再访问。如果一个static域不为final，则对它访问时，要先进行1）和2）的过程。
Class引用也有泛型语法。Class<Integer>,Class<Number>,Class<?>,Class<? extends Number>.为它添加泛型语法主要是为了提供编译期类型检查。
Class引用还有转型语法。classname.class.cast(对象)方法，将对象转为classname类对象.
### 14.3 类型转换前先做检查
RTTI在Java中的三种形式：
1）普通类型转换，比如（Shape），RTTI会确保转换的正确性，否则抛出ClassNotFoundException.
2) Class对象。通过查询Class对象可以获得RTTI。
3）**instanceof**关键字。它返回布尔值，告诉我们某一对象是否为某个类的实例。
这一节没细读，待填坑
### 14.4 注册工厂
介绍了工厂方法的设计模式，待填坑
### 14.5 instanceof与Class等价性
作者给了一个例子，说明instanceof与Class的区别：instanceof含义是“你是这个类或者它的派生类吗？”，而Class是指你的确切类型。
### 14.5 反射：运行时的类信息
在编译时，编译器必需知道所有要通过RTTI来处理的类，也就是说，编译器会在编译时打开和检查.class文件。但是，现实世界很多情况下，无法在编译时获取RTTI。比如：1）在IDE里边拖拽编程。 2）跨网络的远程平台上创建和运行对象，Java程序会将对象分布在多台机器上。这时就有了**反射**。.class文件在编译时不可获取，在运行时才打开与检查。
例子和解说都没看明白，待填坑
### 14.7 动态代理
介绍了**代理**设计模式。待填坑
### 14.8 空对象
**空对象**允许我们假设所有的对象都是有效的，而不必再花精力去判断一个对象是否为null.
作者写了一个扫雪机器人程序，用了代理设计模式，创建了空机器人，需要创建空机器人时，就可以new。照着他的程序敲完，发现还是有点小问题：会抛出空指针异常错误。待填坑。
### 14.9 接口与类型信息
看不懂interface的解耦相关。待填坑。
